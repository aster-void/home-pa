# Calendar Data Flow - Complete Technical Documentation

## Table of Contents

1. [System Architecture Overview](#system-architecture-overview)
2. [Data Models and Types](#data-models-and-types)
3. [Storage Layer](#storage-layer)
4. [Event Creation Flow](#event-creation-flow)
5. [Recurrence System](#recurrence-system)
6. [Display and Rendering](#display-and-rendering)
7. [Timezone Handling](#timezone-handling)
8. [Performance Optimizations](#performance-optimizations)
9. [Error Handling](#error-handling)
10. [Simplification Opportunities](#simplification-opportunities)

## System Architecture Overview

The calendar system follows a layered architecture with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────────┐
│                    UI Layer (Svelte Components)             │
├─────────────────────────────────────────────────────────────┤
│                 Controller Layer (AppController)            │
├─────────────────────────────────────────────────────────────┤
│                   Store Layer (Svelte Stores)              │
├─────────────────────────────────────────────────────────────┤
│                 Service Layer (Recurrence Manager)          │
├─────────────────────────────────────────────────────────────┤
│                   Utility Layer (Date Utils)               │
└─────────────────────────────────────────────────────────────┘
```

### Key Design Principles

- **UTC Storage**: All dates stored in UTC for consistency
- **Local Display**: All UI displays in user's local timezone
- **Visual Truncation**: Multi-day events truncated for display only
- **Lazy Loading**: Heavy dependencies loaded on demand
- **Reactive Updates**: Svelte stores provide automatic reactivity

## Data Models and Types

### Event Data Model

The calendar system supports three distinct event types with different data storage patterns:

#### **All-day Events** (`timeLabel: "all-day"`)

- **Storage**: Date-only (start/end times are 00:00 UTC)
- **Multi-day Support**: Can span multiple days
- **Display**: Shows as "終日" with full height in timeline (00:00-23:59)
- **Use Case**: Events that last the entire day(s) regardless of specific times

#### **Some-timing Events** (`timeLabel: "some-timing"`)

- **Storage**: Date-only (start/end times are 00:00 UTC)
- **Single-day Only**: Start date must equal end date
- **Display**: Shows as "どこかのタイミングで", excluded from timeline
- **Use Case**: Events scheduled for a specific day but time is not yet decided

#### **Timed Events** (`timeLabel: "timed"`)

- **Storage**: Date + actual start/end times in UTC
- **Multi-day Support**: Can span multiple days with specific times
- **Display**: Shows actual times, positioned by time in timeline
- **Use Case**: Events with specific start and end times

### Core Event Interface

```typescript
interface Event {
  id: string; // UUID generated by crypto.randomUUID()
  title: string; // Event title
  start: Date; // UTC Date object - start time
  end: Date; // UTC Date object - end time
  description?: string; // Optional description
  address?: string; // Optional location
  importance?: "low" | "medium" | "high"; // Priority level
  timeLabel: "all-day" | "some-timing" | "timed"; // Event timing type
  tzid?: string; // IANA timezone identifier
  recurrence?: Recurrence; // Recurrence rules
  rdateUtc?: Date[]; // Additional occurrence dates (UTC)
  exdateUtc?: Date[]; // Excluded occurrence dates (UTC)
}
```

### Recurrence Types

```typescript
// No recurrence
type Recurrence = { type: "NONE" };

// RFC-5545 RRULE
type Recurrence = {
  type: "RRULE";
  rrule: string; // Full RRULE string
  frequency?: "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY";
  until?: Date | null; // End date
  count?: number | null; // Number of occurrences
};

// Custom weekly bitmask (optimized for weekly patterns)
type Recurrence = {
  type: "WEEKLY_BITMASK";
  anchorLocalStartISO: string; // Reference start time
  intervalWeeks: number; // Every N weeks
  daysBitmask: number; // Bitmask: 0=Sun, 1=Mon, ..., 6=Sat
  until?: Date | null;
  count?: number | null;
};
```

### Recurrence Occurrence Interface

```typescript
interface RecurrenceOccurrence {
  id: string; // Unique occurrence ID
  eventId: string; // Reference to master event
  startUtc: Date; // UTC start time
  endUtc: Date; // UTC end time
  originalLocalISO: string; // Original local time for display
  title: string; // Copied from master event
  description?: string;
  address?: string;
  importance?: "low" | "medium" | "high";
  timeLabel: "all-day" | "some-timing" | "timed";
  // New sliding window fields
  recurrenceGroupId?: string; // Links events across time windows
  isForever?: boolean; // True for events with no end date
  isDuplicate?: boolean; // True for auto-generated duplicates
  originalEventId?: string; // Reference to original event for duplicates
}
```

## Storage Layer

### Primary Data Store (`src/lib/stores/data.ts`)

The main data store uses Svelte's writable stores for reactive state management:

```typescript
// Core stores
export const events = writable<Event[]>([]);
export const memos = writable<Memo[]>([]);
export const suggestionLogs = writable<SuggestionLog[]>([]);
export const selectedDate = writable<Date>(new Date());

// Event operations with automatic sorting and notifications
export const eventOperations = {
  create(event: Omit<Event, "id">): Event {
    const newEvent = createEvent(event);
    events.update((currentEvents) => sortEvents([...currentEvents, newEvent]));
    toasts.show("Event created successfully", "success");
    return newEvent;
  },

  update(id: string, updates: Partial<Omit<Event, "id">>): Event | null {
    let updatedEvent: Event | null = null;
    events.update((currentEvents) => {
      const index = currentEvents.findIndex((e) => e.id === id);
      if (index === -1) return currentEvents;

      updatedEvent = { ...currentEvents[index], ...updates };
      const newEvents = [...currentEvents];
      newEvents[index] = updatedEvent;
      return sortEvents(newEvents);
    });

    if (updatedEvent) {
      toasts.show("Event updated successfully", "success");
    }
    return updatedEvent;
  },

  delete(id: string): boolean {
    let deleted = false;
    events.update((currentEvents) => {
      const index = currentEvents.findIndex((e) => e.id === id);
      if (index === -1) return currentEvents;

      deleted = true;
      const newEvents = [...currentEvents];
      newEvents.splice(index, 1);
      return newEvents;
    });

    if (deleted) {
      toasts.show("Event deleted", "success");
    }
    return deleted;
  },
};
```

### Recurrence Store (`src/lib/stores/recurrence.store.ts`)

Handles recurring event occurrence generation with lazy loading:

```typescript
export interface RecurrenceState {
  occurrences: RecurrenceOccurrence[];
  loading: boolean;
  error: string | null;
  lastUpdated: Date | null;
}

export const recurrenceStore = writable<RecurrenceState>({
  occurrences: [],
  loading: false,
  error: null,
  lastUpdated: null,
});

// Lazy-loaded manager to avoid SSR issues
let manager: any = null;
let managerPromise: Promise<any> | null = null;

async function getManager() {
  if (manager) return manager;

  if (!managerPromise) {
    managerPromise = import("../services/recurrence/manager.js").then(
      (module) => {
        manager = module.createRecurrenceManager();
        return manager;
      },
    );
  }

  return managerPromise;
}

export async function loadOccurrences(
  events: Event[],
  windowStart: Date,
  windowEnd: Date,
): Promise<void> {
  recurrenceStore.update((s) => ({
    ...s,
    loading: true,
    error: null,
  }));

  try {
    const mgr = await getManager();
    const luxonModule = await import("luxon");
    const DateTime = luxonModule.DateTime;

    await mgr.clearAll();

    // Filter recurring events
    const recurringEvents = events.filter(
      (event) => event.recurrence && event.recurrence.type !== "NONE",
    );

    // Process each recurring event...
    // (See full implementation in the file)

    recurrenceStore.update((s) => ({
      ...s,
      occurrences,
      loading: false,
      error: null,
      lastUpdated: new Date(),
    }));
  } catch (error: any) {
    console.error("Error loading recurrence occurrences:", error);
    recurrenceStore.update((s) => ({
      ...s,
      occurrences: [],
      loading: false,
      error: error.message || "Failed to load recurring events",
      lastUpdated: new Date(),
    }));
  }
}
```

## Event Creation Flow

### 1. User Input Collection

The CalendarView component collects user input through reactive form state:

```typescript
// Form state variables
let eventTitle = $state("");
let eventStartDate = $state("");
let eventEndDate = $state("");
let eventStartTime = $state("");
let eventEndTime = $state("");
let eventAddress = $state("");
let eventImportance = $state<"low" | "medium" | "high">("medium");
let eventTimeLabel = $state<"all-day" | "some-timing" | "timed">("all-day");
let isEventEditing = $state(false);

// Derived state for validation
let hasTimeContent = $derived(
  eventTimeLabel === "timed" &&
    (eventStartTime.trim() !== "" || eventEndTime.trim() !== ""),
);
```

### 2. Form Synchronization

The component maintains bidirectional sync with the controller's form store:

```typescript
// Subscribe to controller store changes
$effect(() => {
  if (controller) {
    const unsubscribe = controller.eventForm.subscribe((form) => {
      eventTitle = form.title;

      // Parse datetime-local format to separate date and time
      if (form.start) {
        const startDateTime = new Date(form.start);
        eventStartDate = utcToLocalDateString(startDateTime);
        eventStartTime = utcToLocalTimeString(startDateTime);
      } else {
        eventStartDate = "";
        eventStartTime = "";
      }

      if (form.end) {
        const endDateTime = new Date(form.end);
        eventEndDate = utcToLocalDateString(endDateTime);
        eventEndTime = utcToLocalTimeString(endDateTime);
      } else {
        eventEndDate = "";
        eventEndTime = "";
      }

      // Override time fields based on time label
      if (form.timeLabel === "all-day") {
        eventStartTime = "00:00";
        eventEndTime = "23:59";
      } else if (form.timeLabel === "some-timing") {
        eventStartTime = "";
        eventEndTime = "";
      } else if (form.timeLabel === "timed") {
        // For timed events, keep the actual time values from the form
        // Don't override them
      }

      eventAddress = form.address || "";
      eventImportance = form.importance || "medium";
      eventTimeLabel = form.timeLabel || "all-day";
      isEventEditing = form.isEditing;
    });
  }
});

// Sync changes back to controller
$effect(() => {
  if (controller && !syncInProgress) {
    untrack(() => {
      const startDateTime =
        eventStartDate && eventStartTime
          ? localDateTimeToUTC(eventStartDate, eventStartTime)
              .toISOString()
              .slice(0, 16)
          : "";
      const endDateTime =
        eventEndDate && eventEndTime
          ? localDateTimeToUTC(eventEndDate, eventEndTime)
              .toISOString()
              .slice(0, 16)
          : "";

      const currentForm = get(controller.eventForm);
      if (
        startDateTime !== currentForm.start ||
        endDateTime !== currentForm.end
      ) {
        syncInProgress = true;
        controller.eventForm.update((form) => ({
          ...form,
          start: startDateTime,
          end: endDateTime,
        }));
        syncInProgress = false;
      }
    });
  }
});
```

### 3. Controller Processing

The AppController handles the business logic for event creation:

```typescript
createEvent(): void {
  const formData = get(this.eventForm);

  // Validation
  if (!formData.title?.trim()) {
    alert("タイトルを入力してください");
    return;
  }

  // Only require start/end times if time fields have content
  if ((formData.start || formData.end) && (!formData.start || !formData.end)) {
    alert("開始時間と終了時間を入力してください");
    return;
  }

  // Create UTC dates for storage based on time label
  let startDate: Date;
  let endDate: Date;

  if (formData.start && formData.end) {
    // Parse datetime-local format and convert to UTC
    startDate = new Date(formData.start);
    endDate = new Date(formData.end);

    if (startDate >= endDate) {
      alert("終了時間は開始時間より後にしてください");
      return;
    }

    // Check if event is in the past (only for specific-time events)
    const now = new Date();
    if (startDate < now) {
      alert("過去の時間に予定を作成することはできません");
      return;
    }
  } else {
    // For date-only events (all-day, some-timing)
    let startDateStr: string;
    let endDateStr: string;

    if (formData.start && formData.end) {
      // Extract date parts (remove time if present)
      startDateStr = formData.start.includes('T') ? formData.start.split('T')[0] : formData.start;
      endDateStr = formData.end.includes('T') ? formData.end.split('T')[0] : formData.end;
    } else {
      // Use selected date as fallback
      const currentSelectedDate = get(selectedDate);
      const dateString = utcToLocalDateString(currentSelectedDate);
      startDateStr = dateString;
      endDateStr = dateString;
    }

    if (formData.timeLabel === "some-timing") {
      // Some-timing events: start and end must be the same date (single day only)
      const dateOnly = createDateOnlyUTC(startDateStr);
      startDate = dateOnly;
      endDate = dateOnly;
    } else {
      // All-day events: can span multiple days
      if (startDateStr === endDateStr) {
        // Single day all-day event - start and end are the same (date at 00:00 UTC)
        const dateOnly = createDateOnlyUTC(startDateStr);
        startDate = dateOnly;
        endDate = dateOnly;
      } else {
        // Multi-day all-day event - start is first day, end is last day (both at 00:00 UTC)
        const range = createMultiDayAllDayUTCRange(startDateStr, endDateStr);
        startDate = range.start;
        endDate = range.end;
      }
    }
  }

  const newEvent = eventOperations.create({
    title: formData.title.trim(),
    start: startDate,
    end: endDate,
    description: formData.description?.trim() || undefined,
    address: formData.address?.trim() || undefined,
    importance: formData.importance || "medium",
    timeLabel: formData.timeLabel || "all-day",
  });

  this.resetEventForm();
  this.checkForSuggestion();
}
```

### 4. Date Utility Functions

The date utilities handle timezone conversions and special date ranges:

```typescript
/**
 * Creates an all-day UTC Date range from a local date string
 * Used for all-day events
 */
export function createAllDayUTCRange(dateString: string): {
  start: Date;
  end: Date;
} {
  if (!dateString) {
    const now = new Date();
    const start = new Date(
      Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()),
    );
    const end = new Date(
      Date.UTC(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        23,
        59,
        59,
        999,
      ),
    );
    return { start, end };
  }

  const [year, month, day] = dateString.split("-").map(Number);
  const start = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
  const end = new Date(Date.UTC(year, month - 1, day, 23, 59, 59, 999));
  return { start, end };
}

/**
 * Creates a multi-day all-day UTC Date range from start and end date strings
 * Used for all-day events that span multiple days
 */
export function createMultiDayAllDayUTCRange(
  startDateString: string,
  endDateString: string,
): { start: Date; end: Date } {
  if (!startDateString || !endDateString) {
    const now = new Date();
    const start = new Date(
      Date.UTC(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0),
    );
    const end = new Date(
      Date.UTC(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        23,
        59,
        59,
        999,
      ),
    );
    return { start, end };
  }

  const [startYear, startMonth, startDay] = startDateString
    .split("-")
    .map(Number);
  const [endYear, endMonth, endDay] = endDateString.split("-").map(Number);

  const start = new Date(
    Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0),
  );
  const end = new Date(
    Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59, 999),
  );
  return { start, end };
}

/**
 * Creates a UTC Date object from local date and time strings
 * Used when combining separate date and time inputs
 */
export function localDateTimeToUTC(
  dateString: string,
  timeString: string,
): Date {
  if (!dateString) return new Date();

  const [year, month, day] = dateString.split("-").map(Number);

  if (!timeString) {
    // If no time, create date at start of day UTC
    return new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
  }

  const [hours, minutes] = timeString.split(":").map(Number);
  return new Date(Date.UTC(year, month - 1, day, hours, minutes));
}
```

## Recurrence System

### Sliding Window Architecture

The recurrence system now uses a **7-month sliding window** approach for efficient memory management and forever event handling:

#### Window Configuration

- **Size**: 7 months (3 before + current + 3 after)
- **Auto-shift**: Automatically shifts when user navigates beyond current window
- **Memory efficient**: Only loads necessary data instead of years of events
- **Forever events**: Special handling with visual indicators (∞)

### Recurrence Manager Architecture

The recurrence system uses a sophisticated in-memory manager with the following features:

#### Core Manager Interface

```typescript
export interface RecurrenceManager {
  createEvent(
    ev: Omit<EventMaster, "id" | "createdAtUtc" | "updatedAtUtc">,
  ): Promise<EventMaster>;
  updateEvent(
    id: ID,
    patch: Partial<Omit<EventMaster, "id" | "createdAtUtc">>,
  ): Promise<EventMaster>;
  deleteEvent(id: ID): Promise<void>;

  createOverride(
    ov: Omit<OccurrenceOverride, "id" | "createdAtUtc">,
  ): Promise<OccurrenceOverride>;
  updateOverride(
    id: ID,
    patch: Partial<OccurrenceOverride>,
  ): Promise<OccurrenceOverride>;
  deleteOverride(id: ID): Promise<void>;

  getOccurrencesWindow(
    windowStartUtc: Date,
    windowEndUtc: Date,
  ): Promise<Occurrence[]>;

  clearAll(): Promise<void>;
  _dumpState(): Promise<{
    events: EventMaster[];
    overrides: OccurrenceOverride[];
    cachedOccurrences?: Occurrence[];
  }>;
}
```

#### Event Master Structure

```typescript
export interface EventMaster {
  id: ID;
  title: string;
  description?: string;
  address?: string;
  importance?: "low" | "medium" | "high";
  timeLabel: "all-day" | "some-timing" | "timed";
  startLocalISO: string; // Local time as ISO string
  tzid: string; // IANA timezone
  durationMs: number; // Duration in milliseconds
  recurrence: Recurrence; // Recurrence rules
  rdateUtc?: Date[]; // Additional dates (UTC)
  exdateUtc?: Date[]; // Excluded dates (UTC)
  createdAtUtc: Date;
  updatedAtUtc?: Date;
  meta?: Record<string, any>;
}
```

### RRULE Processing

The system uses rrule.js for RFC-5545 compliance:

```typescript
function generateRRuleOccurrences(
  event: EventMaster,
  rule: RecurrenceRuleRFC,
  windowStartUtc: Date,
  windowEndUtc: Date,
): Occurrence[] {
  const occurrences: Occurrence[] = [];

  try {
    // Parse the RRULE string with timezone awareness
    const localDt = DateTime.fromISO(event.startLocalISO, { zone: event.tzid });
    if (!localDt.isValid) {
      return [];
    }

    // For rrule.js to work correctly with BYDAY in local timezone,
    // we need to use Date.UTC() with local time values
    const dtstart = new Date(
      Date.UTC(
        localDt.year,
        localDt.month - 1,
        localDt.day,
        localDt.hour,
        localDt.minute,
        localDt.second,
      ),
    );

    const rruleSet = new RRuleSet();
    const rrule = rrulestr(rule.rrule, { dtstart });
    rruleSet.rrule(rrule);

    // Generate occurrences with safety limit
    const expandedStart = new Date(
      dtstart.getTime() - 365 * 24 * 60 * 60 * 1000,
    ); // 1 year before
    const expandedEnd = new Date(
      dtstart.getTime() + 2 * 365 * 24 * 60 * 60 * 1000,
    ); // 2 years after

    const rawInstances = rruleSet.between(
      expandedStart,
      expandedEnd,
      true, // inclusive
      (date, i) => i < MAX_OCCURRENCES_PER_QUERY,
    );

    // Process each instance with timezone conversion
    for (const instanceNaive of rawInstances) {
      const localDt = DateTime.fromObject(
        {
          year: instanceNaive.getUTCFullYear(),
          month: instanceNaive.getUTCMonth() + 1,
          day: instanceNaive.getUTCDate(),
          hour: instanceNaive.getUTCHours(),
          minute: instanceNaive.getUTCMinutes(),
          second: instanceNaive.getUTCSeconds(),
        },
        { zone: event.tzid },
      );

      const localISO = localDt.toISO({
        suppressMilliseconds: true,
        includeOffset: false,
      })!;
      const instanceUtc = localDt.toUTC().toJSDate();

      // Check if this occurrence is within the actual window
      if (instanceUtc < windowStartUtc || instanceUtc > windowEndUtc) {
        continue;
      }

      // Validate time consistency for DST handling
      if (shouldValidateTime) {
        const originalDt = DateTime.fromISO(event.startLocalISO, {
          zone: event.tzid,
        });
        if (
          localDt.hour !== originalDt.hour ||
          localDt.minute !== originalDt.minute ||
          localDt.second !== originalDt.second
        ) {
          continue; // Skip DST-adjusted times
        }
      }

      occurrences.push({
        eventId: event.id,
        startUtc: instanceUtc,
        endUtc: new Date(instanceUtc.getTime() + event.durationMs),
        originalLocalISO: localISO,
      });
    }
  } catch (error) {
    console.error("Error generating RRULE occurrences:", error);
  }

  return occurrences;
}
```

### Weekly Bitmask Optimization

For weekly patterns, the system uses an optimized bitmask approach:

```typescript
function generateWeeklyBitmaskOccurrences(
  event: EventMaster,
  rule: WeeklyBitmaskRule,
  windowStartUtc: Date,
  windowEndUtc: Date,
): Occurrence[] {
  const occurrences: Occurrence[] = [];
  const anchorDT = DateTime.fromISO(rule.anchorLocalStartISO, {
    zone: event.tzid,
  });

  if (!anchorDT.isValid) {
    return [];
  }

  const days = getDaysFromBitmask(rule.daysBitmask);
  if (days.length === 0) {
    return [];
  }

  const windowStartDT = DateTime.fromJSDate(windowStartUtc, {
    zone: "utc",
  }).setZone(event.tzid);
  const windowEndDT = DateTime.fromJSDate(windowEndUtc, {
    zone: "utc",
  }).setZone(event.tzid);

  // Start from a few weeks before window to ensure we catch all occurrences
  const startWeek = anchorDT.startOf("week");
  const weeksFromAnchor = Math.floor(
    windowStartDT.diff(startWeek, "weeks").weeks,
  );
  const firstCheckWeek = startWeek.plus({
    weeks: Math.max(0, weeksFromAnchor - rule.intervalWeeks),
  });

  let currentWeek = firstCheckWeek;
  let count = 0;
  const maxCount = rule.count ?? Infinity;
  const untilDT = rule.until
    ? DateTime.fromJSDate(rule.until, { zone: event.tzid })
    : null;

  // Generate occurrences week by week
  while (
    currentWeek <= windowEndDT &&
    count < maxCount &&
    occurrences.length < MAX_OCCURRENCES_PER_QUERY
  ) {
    // Check if this week matches the interval pattern
    const weeksDiff = currentWeek.diff(anchorDT.startOf("week"), "weeks").weeks;
    if (weeksDiff >= 0 && weeksDiff % rule.intervalWeeks === 0) {
      // Generate occurrences for each day in the bitmask
      for (const dayOfWeek of days) {
        const luxonWeekday = (dayOfWeek === 0 ? 7 : dayOfWeek) as
          | 1
          | 2
          | 3
          | 4
          | 5
          | 6
          | 7;
        const occurrenceDT = currentWeek.set({
          weekday: luxonWeekday, // Luxon: 1=Monday, 7=Sunday
          hour: anchorDT.hour,
          minute: anchorDT.minute,
          second: anchorDT.second,
          millisecond: anchorDT.millisecond,
        });

        // Check validity (DST non-existent check)
        if (!occurrenceDT.isValid) {
          continue; // Skip non-existent times
        }

        // Check against until
        if (untilDT && occurrenceDT > untilDT) {
          break;
        }

        // Check if in window
        const occurrenceUtc = occurrenceDT.toJSDate();
        if (occurrenceUtc >= windowStartUtc && occurrenceUtc <= windowEndUtc) {
          occurrences.push({
            eventId: event.id,
            startUtc: occurrenceUtc,
            endUtc: new Date(occurrenceUtc.getTime() + event.durationMs),
            originalLocalISO: occurrenceDT.toISO({
              suppressMilliseconds: true,
              includeOffset: false,
            })!,
          });
          count++;
          if (count >= maxCount) break;
        } else if (occurrenceUtc > windowEndUtc) {
          break;
        }
      }
    }

    currentWeek = currentWeek.plus({ weeks: rule.intervalWeeks });
  }

  return occurrences;
}
```

### Occurrence Generation Process

The complete occurrence generation follows this sequence:

1. **Base Recurrence Generation**
   - RRULE: Uses rrule.js with timezone-aware processing
   - Weekly Bitmask: Custom optimized algorithm
   - NONE: Single occurrence

2. **RDATE Addition**
   - Add explicit additional occurrence dates
   - Convert from local time to UTC for storage

3. **EXDATE Removal**
   - Remove explicitly excluded dates
   - Uses time-based comparison for precision

4. **Override Application**
   - Apply occurrence-specific modifications
   - Handle cancellations, time changes, duration changes
   - Support for moving occurrences

5. **Deduplication and Sorting**
   - Merge occurrences from all sources
   - Sort by start time
   - Apply safety limits (20,000 occurrences max)

```typescript
async function getOccurrencesWindow(
  windowStartUtc: Date,
  windowEndUtc: Date,
): Promise<Occurrence[]> {
  const allOccurrences: Occurrence[] = [];

  for (const event of events.values()) {
    const eventOccurrences: Occurrence[] = [];

    // 1. Generate base recurrence occurrences
    if (event.recurrence.type === "RRULE") {
      const generated = generateRRuleOccurrences(
        event,
        event.recurrence,
        windowStartUtc,
        windowEndUtc,
      );
      eventOccurrences.push(...generated);
    } else if (event.recurrence.type === "WEEKLY_BITMASK") {
      const generated = generateWeeklyBitmaskOccurrences(
        event,
        event.recurrence,
        windowStartUtc,
        windowEndUtc,
      );
      eventOccurrences.push(...generated);
    } else if (event.recurrence.type === "NONE") {
      // Single occurrence
      const startUtc = localISOToUTC(event.startLocalISO, event.tzid);
      if (startUtc && startUtc >= windowStartUtc && startUtc <= windowEndUtc) {
        eventOccurrences.push({
          eventId: event.id,
          startUtc,
          endUtc: new Date(startUtc.getTime() + event.durationMs),
          originalLocalISO: event.startLocalISO,
        });
      }
    }

    // 2. Add RDATE occurrences (explicit additional dates)
    if (event.rdateUtc && event.rdateUtc.length > 0) {
      for (const rdateUtc of event.rdateUtc) {
        const inWindow = rdateUtc >= windowStartUtc && rdateUtc <= windowEndUtc;
        if (inWindow) {
          const localISO = utcToLocalISO(rdateUtc, event.tzid);
          eventOccurrences.push({
            eventId: event.id,
            startUtc: rdateUtc,
            endUtc: new Date(rdateUtc.getTime() + event.durationMs),
            originalLocalISO: localISO,
          });
        }
      }
    }

    // 3. Remove EXDATE occurrences (explicit exclusions)
    const exdateSet = new Set((event.exdateUtc ?? []).map((d) => d.getTime()));
    const filteredOccurrences = eventOccurrences.filter(
      (occ) => !exdateSet.has(occ.startUtc.getTime()),
    );

    // 4. Apply overrides
    const eventOverrides = Array.from(overrides.values()).filter(
      (ov) => ov.eventId === event.id,
    );

    // Remove cancelled occurrences
    const cancelledLocalISOs = new Set(
      eventOverrides
        .filter((ov) => ov.isCancelled && ov.originalLocalISO)
        .map((ov) => ov.originalLocalISO!),
    );

    const nonCancelledOccurrences = filteredOccurrences.filter(
      (occ) => !cancelledLocalISOs.has(occ.originalLocalISO),
    );

    // Apply modifications and additions
    for (const override of eventOverrides) {
      if (override.isCancelled) {
        continue; // Already handled above
      }

      if (override.newStartUtc) {
        // This is a moved or new occurrence
        const newStartUtc = override.newStartUtc;
        if (newStartUtc >= windowStartUtc && newStartUtc <= windowEndUtc) {
          const localISO = utcToLocalISO(newStartUtc, event.tzid);
          const durationMs = override.newDurationMs ?? event.durationMs;

          // Remove original if it exists
          const originalIdx = nonCancelledOccurrences.findIndex(
            (occ) => occ.originalLocalISO === override.originalLocalISO,
          );
          if (originalIdx >= 0) {
            nonCancelledOccurrences.splice(originalIdx, 1);
          }

          // Add the modified occurrence
          nonCancelledOccurrences.push({
            id: override.id,
            eventId: event.id,
            startUtc: newStartUtc,
            endUtc: new Date(newStartUtc.getTime() + durationMs),
            originalLocalISO: localISO,
            overrideId: override.id,
          });
        }
      }
    }

    allOccurrences.push(...nonCancelledOccurrences);
  }

  // Deduplicate and sort
  const deduplicated = deduplicateOccurrences(allOccurrences);

  // Check for truncation
  if (deduplicated.length >= MAX_OCCURRENCES_PER_QUERY) {
    console.warn(
      `Occurrence limit reached: ${MAX_OCCURRENCES_PER_QUERY}. Results may be truncated.`,
    );
  }

  return deduplicated.slice(0, MAX_OCCURRENCES_PER_QUERY);
}
```

## Display and Rendering

### Event Filtering and Truncation

The display layer implements visual truncation for multi-day events while preserving original data:

```typescript
// Helper function to get events for a specific date (including midnight-crossing events)
function getEventsForDate(events: Event[], targetDate: Date): Event[] {
  const targetDateStart = new Date(targetDate);
  targetDateStart.setHours(0, 0, 0, 0);
  const targetDateEnd = new Date(targetDate);
  targetDateEnd.setHours(23, 59, 59, 999);
  const targetDateStartTime = targetDateStart.getTime();
  const targetDateEndTime = targetDateEnd.getTime();

  return events
    .filter((event) => {
      const eventStartDate = new Date(event.start);
      const eventEndDate = new Date(event.end);
      const eventStartTime = eventStartDate.getTime();
      const eventEndTime = eventEndDate.getTime();

      // Include events where target date falls between start and end (inclusive)
      return (
        eventStartTime <= targetDateEndTime &&
        eventEndTime >= targetDateStartTime
      );
    })
    .map((event) => {
      const eventStartDate = new Date(event.start);
      const eventEndDate = new Date(event.end);
      const eventStartTime = eventStartDate.getTime();
      const eventEndTime = eventEndDate.getTime();

      const startsOnTarget =
        eventStartTime >= targetDateStartTime &&
        eventStartTime <= targetDateEndTime;
      const endsOnTarget =
        eventEndTime >= targetDateStartTime &&
        eventEndTime <= targetDateEndTime;
      const spansTarget =
        eventStartTime < targetDateStartTime &&
        eventEndTime > targetDateEndTime;

      // If event starts and ends on the same day, return as is
      if (startsOnTarget && endsOnTarget) {
        return event;
      }

      // If event starts on target date but ends next day, truncate at midnight
      if (startsOnTarget && !endsOnTarget) {
        const truncatedEnd = new Date(targetDate);
        truncatedEnd.setHours(23, 59, 59, 999);
        return {
          ...event,
          end: truncatedEnd,
        };
      }

      // If event ends on target date but started yesterday, start at midnight
      if (!startsOnTarget && endsOnTarget) {
        const truncatedStart = new Date(targetDate);
        truncatedStart.setHours(0, 0, 0, 0);
        return {
          ...event,
          start: truncatedStart,
        };
      }

      // If event spans the target date (starts before and ends after), truncate to full day
      if (spansTarget) {
        const truncatedStart = new Date(targetDate);
        truncatedStart.setHours(0, 0, 0, 0);
        const truncatedEnd = new Date(targetDate);
        truncatedEnd.setHours(23, 59, 59, 999);
        return {
          ...event,
          start: truncatedStart,
          end: truncatedEnd,
        };
      }

      return event;
    });
}

// Helper function to get events for timeline (includes timed and all-day events)
function getEventsForTimeline(events: Event[], targetDate: Date): Event[] {
  return getEventsForDate(events, targetDate).filter((event) => {
    // Include timed events (positioned by time) and all-day events (full height)
    // Exclude some-timing events (they don't have specific times)
    return event.timeLabel === "timed" || event.timeLabel === "all-day";
  });
}
```

### Timeline Rendering

The timeline view uses column-based layout to handle overlapping events:

```typescript
function getEventColumns(events: Event[]): Event[][] {
  if (events.length === 0) return [];

  // Sort events by start time
  const sortedEvents = [...events].sort(
    (a, b) => a.start.getTime() - b.start.getTime(),
  );

  const columns: Event[][] = [];

  for (const event of sortedEvents) {
    // Find the first column where this event doesn't overlap
    let columnIndex = 0;
    while (columnIndex < columns.length) {
      const column = columns[columnIndex];
      const lastEvent = column[column.length - 1];

      // Check if this event overlaps with the last event in this column
      if (event.start >= lastEvent.end) {
        break;
      }
      columnIndex++;
    }

    // If no suitable column found, create a new one
    if (columnIndex >= columns.length) {
      columns.push([]);
    }

    columns[columnIndex].push(event);
  }

  return columns;
}
```

### Multi-day Event Layout

Multi-day events maintain consistent row positioning across days:

```typescript
// Assign row indices to events so multi-day events maintain same row across days
function assignEventRows(events: Event[]): Map<string, number> {
  const eventRows = new Map<string, number>();

  // Sort events by start date, then by duration (longer first)
  const sortedEvents = [...events].sort((a, b) => {
    const startDiff = a.start.getTime() - b.start.getTime();
    if (startDiff !== 0) return startDiff;
    // If same start, longer events first
    const aDuration = a.end.getTime() - a.start.getTime();
    const bDuration = b.end.getTime() - b.start.getTime();
    return bDuration - aDuration;
  });

  for (const event of sortedEvents) {
    const eventStartDate = new Date(event.start);
    eventStartDate.setHours(0, 0, 0, 0);
    const eventEndDate = new Date(event.end);
    eventEndDate.setHours(0, 0, 0, 0);

    // Find the first available row
    let row = 0;
    let rowAvailable = false;

    while (!rowAvailable) {
      rowAvailable = true;

      // Check against all previously assigned events
      for (const [otherEventId, otherRow] of eventRows) {
        if (otherRow === row) {
          const otherEvent = events.find((e) => e.id === otherEventId);
          if (otherEvent) {
            const otherStartDate = new Date(otherEvent.start);
            otherStartDate.setHours(0, 0, 0, 0);
            const otherEndDate = new Date(otherEvent.end);
            otherEndDate.setHours(0, 0, 0, 0);

            // Check if events overlap in date range
            if (
              eventStartDate.getTime() <= otherEndDate.getTime() &&
              eventEndDate.getTime() >= otherStartDate.getTime()
            ) {
              rowAvailable = false;
              break;
            }
          }
        }
      }

      if (!rowAvailable) {
        row++;
      }
    }

    eventRows.set(event.id, row);
  }

  return eventRows;
}
```

## Timezone Handling

### Core Timezone Policy

The system follows a strict timezone policy:

1. **Storage**: All dates stored in UTC
2. **Recurrence**: Rules evaluated in event's timezone (tzid)
3. **Display**: All UI shows local time
4. **DST Handling**:
   - Non-existent times (DST forward): Skip occurrence
   - Ambiguous times (DST backward): Use earlier instant

### Timezone Conversion Functions

```typescript
/**
 * Convert local ISO string + tzid to UTC Date
 * Handles DST ambiguity by using the earlier instant
 */
function localISOToUTC(localISO: string, tzid: string): Date | null {
  const dt = DateTime.fromISO(localISO, { zone: tzid });
  if (!dt.isValid) {
    return null; // Invalid/non-existent time (DST skip)
  }
  return dt.toJSDate();
}

/**
 * Convert UTC Date to local ISO string in given timezone
 */
function utcToLocalISO(utcDate: Date, tzid: string): string {
  return DateTime.fromJSDate(utcDate, { zone: "utc" })
    .setZone(tzid)
    .toISO({ suppressMilliseconds: true, includeOffset: false })!;
}

/**
 * Converts a UTC Date object to local date string (YYYY-MM-DD)
 * Used when displaying in UI
 */
export function utcToLocalDateString(utcDate: Date): string {
  const year = utcDate.getFullYear();
  const month = String(utcDate.getMonth() + 1).padStart(2, "0");
  const day = String(utcDate.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

/**
 * Converts a UTC Date object to local datetime string (YYYY-MM-DDTHH:MM)
 * Used when displaying in UI
 */
export function utcToLocalDateTimeString(utcDate: Date): string {
  const year = utcDate.getFullYear();
  const month = String(utcDate.getMonth() + 1).padStart(2, "0");
  const day = String(utcDate.getDate()).padStart(2, "0");
  const hours = String(utcDate.getHours()).padStart(2, "0");
  const minutes = String(utcDate.getMinutes()).padStart(2, "0");
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}

/**
 * Converts a UTC Date object to local time string (HH:MM)
 * Used when displaying time in UI
 */
export function utcToLocalTimeString(utcDate: Date): string {
  const hours = String(utcDate.getHours()).padStart(2, "0");
  const minutes = String(utcDate.getMinutes()).padStart(2, "0");
  return `${hours}:${minutes}`;
}
```

### DST Handling in Recurrence

The system handles DST transitions carefully:

```typescript
// Check validity (DST non-existent check)
if (!occurrenceDT.isValid) {
  continue; // Skip non-existent times
}

// For DAILY/WEEKLY: Check if the local time matches the expected hour/minute from the original event
const shouldValidateTime =
  rule.frequency === "DAILY" ||
  rule.frequency === "WEEKLY" ||
  rule.rrule.includes("FREQ=DAILY") ||
  rule.rrule.includes("FREQ=WEEKLY");

if (shouldValidateTime) {
  const originalDt = DateTime.fromISO(event.startLocalISO, {
    zone: event.tzid,
  });
  if (
    localDt.hour !== originalDt.hour ||
    localDt.minute !== originalDt.minute ||
    localDt.second !== originalDt.second
  ) {
    // Time was adjusted due to DST, skip it
    continue;
  }
}
```

## Performance Optimizations

### Lazy Loading

The recurrence manager is lazy-loaded to avoid SSR issues and reduce initial bundle size:

```typescript
// Singleton manager instance (lazy loaded)
let manager: any = null;
let managerPromise: Promise<any> | null = null;

async function getManager() {
  if (manager) return manager;

  if (!managerPromise) {
    managerPromise = import("../services/recurrence/manager.js").then(
      (module) => {
        manager = module.createRecurrenceManager();
        return manager;
      },
    );
  }

  return managerPromise;
}
```

### Occurrence Limits

Safety limits prevent runaway recurrence rules:

```typescript
const MAX_OCCURRENCES_PER_QUERY = 20000;

// Check for truncation
if (deduplicated.length >= MAX_OCCURRENCES_PER_QUERY) {
  console.warn(
    `Occurrence limit reached: ${MAX_OCCURRENCES_PER_QUERY}. Results may be truncated.`,
  );
}

return deduplicated.slice(0, MAX_OCCURRENCES_PER_QUERY);
```

### Caching Strategy

The recurrence store implements caching with invalidation:

```typescript
// Invalidate cache for a specific event
function invalidateCache(eventId?: ID): void {
  if (eventId) {
    // Remove only entries for this event
    for (const [key, _] of occurrenceCache) {
      if (key.startsWith(`${eventId}-`)) {
        occurrenceCache.delete(key);
      }
    }
  } else {
    // Clear all cache
    occurrenceCache.clear();
  }
}
```

### Refresh Optimization

Occurrences are refreshed only when needed:

```typescript
/**
 * Check if occurrences need refresh (older than 5 minutes)
 */
export function needsRefresh(lastUpdated: Date | null): boolean {
  if (!lastUpdated) return true;
  const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
  return lastUpdated.getTime() < fiveMinutesAgo;
}
```

## Error Handling

### Graceful Degradation

The system handles errors gracefully at multiple levels:

```typescript
// Recurrence store error handling
try {
  const mgr = await getManager();
  // ... process occurrences
} catch (error: any) {
  console.error("Error loading recurrence occurrences:", error);
  recurrenceStore.update((s) => ({
    ...s,
    occurrences: [],
    loading: false,
    error: error.message || "Failed to load recurring events",
    lastUpdated: new Date(),
  }));
}

// RRULE generation error handling
try {
  // ... generate occurrences
} catch (error) {
  console.error("Error generating RRULE occurrences:", error);
  return []; // Return empty array on error
}
```

### Validation

Input validation prevents invalid data:

```typescript
// Event creation validation
if (!formData.title?.trim()) {
  alert("タイトルを入力してください");
  return;
}

if (startDate >= endDate) {
  alert("終了時間は開始時間より後にしてください");
  return;
}

// Past event validation
const now = new Date();
if (startDate < now) {
  alert("過去の時間に予定を作成することはできません");
  return;
}
```

### DST Error Handling

Invalid times due to DST are handled gracefully:

```typescript
// Skip invalid times (DST non-existent)
if (!occurrenceDT.isValid) {
  continue; // Skip non-existent times
}

// Return null for invalid conversions
function localISOToUTC(localISO: string, tzid: string): Date | null {
  const dt = DateTime.fromISO(localISO, { zone: tzid });
  if (!dt.isValid) {
    return null; // Invalid/non-existent time (DST skip)
  }
  return dt.toJSDate();
}
```

## Simplification Opportunities

Based on the analysis, here are areas where the system could be simplified:

### 1. Date Handling Consolidation

**Current State**: Multiple date conversion functions scattered across utilities
**Simplification**: Create a unified DateManager class

```typescript
class DateManager {
  static toUTC(localISO: string, tzid: string): Date | null;
  static toLocalISO(utcDate: Date, tzid: string): string;
  static createAllDayRange(dateString: string): { start: Date; end: Date };
  static createMultiDayRange(
    start: string,
    end: string,
  ): { start: Date; end: Date };
  static formatForDisplay(
    utcDate: Date,
    format: "date" | "time" | "datetime",
  ): string;
}
```

### 2. Form State Management

**Current State**: Complex bidirectional sync between controller and component
**Simplification**: Use a single source of truth with derived state

```typescript
// Single form store with derived fields
const eventForm = writable<EventFormData>({...});

// Derived stores for individual fields
export const eventTitle = derived(eventForm, $form => $form.title);
export const eventStartDate = derived(eventForm, $form => parseDate($form.start));
export const eventStartTime = derived(eventForm, $form => parseTime($form.start));
```

### 3. Recurrence Manager Interface

**Current State**: Complex async interface with multiple methods
**Simplification**: Simplified interface focusing on core operations

```typescript
interface SimpleRecurrenceManager {
  generateOccurrences(events: Event[], window: DateRange): Occurrence[];
  addEvent(event: Event): void;
  removeEvent(eventId: string): void;
  updateEvent(eventId: string, updates: Partial<Event>): void;
}
```

### 4. Display Logic Extraction

**Current State**: Display logic mixed with component logic
**Simplification**: Extract to pure utility functions

```typescript
// Pure functions for display logic
export const DisplayUtils = {
  truncateEventForDate(event: Event, date: Date): Event,
  getEventColumns(events: Event[]): Event[][],
  assignEventRows(events: Event[]): Map<string, number>,
  filterEventsForTimeline(events: Event[], date: Date): Event[]
};
```

### 5. Event Type Implementation

**Current State**: Three distinct event types with clear data storage patterns
**Implementation**: Event types with proper data handling

```typescript
type EventType = "all-day" | "some-timing" | "timed";

interface Event {
  id: string;
  title: string;
  timeLabel: EventType;
  start: Date; // UTC - actual times for timed, 00:00 for date-only
  end: Date; // UTC - actual times for timed, 00:00 for date-only
  description?: string;
  address?: string;
  importance?: "low" | "medium" | "high";
  tzid?: string;
  recurrence?: Recurrence;
}
```

### 6. Store Architecture

**Current State**: Multiple stores with complex interactions
**Simplification**: Single store with derived views

```typescript
// Single source of truth
const appState = writable<AppState>({
  events: [],
  selectedDate: new Date(),
  viewMode: "day",
});

// Derived stores for specific views
export const todaysEvents = derived(appState, ($state) =>
  $state.events.filter((e) => isSameDay(e.start, $state.selectedDate)),
);

export const timelineEvents = derived(appState, ($state) =>
  $state.events.filter(
    (e) =>
      (e.timeLabel === "timed" || e.timeLabel === "all-day") &&
      isSameDay(e.start, $state.selectedDate),
  ),
);
```

## Complete Example: Recurring Event Creation and Data Flow

Let's walk through a complete example of creating a recurring weekly meeting and trace the data flow through the entire system.

### Example: "Weekly Team Meeting" Event

**User Input:**

- Title: "Weekly Team Meeting"
- Start Date: 2024-01-15 (Monday)
- Start Time: (empty - time not decided)
- End Time: (empty - time not decided)
- Recurrence: Every Monday
- Timezone: Asia/Tokyo (JST)
- Description: "Weekly team sync - time TBD"

### Step 1: User Interface Input Collection

```typescript
// CalendarView.svelte - Form state
let eventTitle = $state("Weekly Team Meeting");
let eventStartDate = $state("2024-01-15");
let eventEndDate = $state("2024-01-15");
let eventStartTime = $state(""); // Empty - time not decided
let eventEndTime = $state(""); // Empty - time not decided
let eventTimeLabel = $state<"all-day" | "some-timing" | "timed">("some-timing");
let isRecurring = $state(true);
let recurrenceFrequency = $state<"WEEKLY">("WEEKLY");
let weeklyDays = $state<boolean[]>([
  false,
  true,
  false,
  false,
  false,
  false,
  false,
]); // Monday only
```

### Step 2: Form Synchronization with Controller

```typescript
// Bidirectional sync between component and controller
$effect(() => {
  if (controller && !syncInProgress) {
    // For some-timing events, no datetime is set - only date
    const startDateTime = ""; // Empty because time is not decided
    const endDateTime = ""; // Empty because time is not decided

    controller.eventForm.update((form) => ({
      ...form,
      title: eventTitle,
      start: startDateTime,
      end: endDateTime,
      description: "Weekly team sync - time TBD",
      timeLabel: "some-timing",
    }));
  }
});
```

### Step 3: Controller Processing and Validation

```typescript
// AppController.createEvent()
createEvent(): void {
  const formData = get(this.eventForm);

  // Validation
  if (!formData.title?.trim()) {
    alert("タイトルを入力してください");
    return;
  }

  // For some-timing events, use selected date with zero duration
  const currentSelectedDate = get(selectedDate);
  const dateString = `${currentSelectedDate.getFullYear()}-${String(currentSelectedDate.getMonth() + 1).padStart(2, '0')}-${String(currentSelectedDate.getDate()).padStart(2, '0')}`;

  if (formData.timeLabel === "some-timing") {
    // For some-timing events, start and end must be the same date (single day only)
    const dateOnly = createDateOnlyUTC(dateString);
    const startDate = dateOnly;
    const endDate = dateOnly; // Same time = zero duration
  }

  // Create the base event
  const newEvent = eventOperations.create({
    title: "Weekly Team Meeting",
    start: startDate,
    end: endDate,
    description: "Weekly team sync - time TBD",
    timeLabel: "some-timing",
    importance: "medium",
    tzid: "Asia/Tokyo"
  });

  // Build recurrence object
  const recurrence = buildRecurrenceObject();
  // recurrence = {
  //   type: "WEEKLY_BITMASK",
  //   anchorLocalStartISO: "2024-01-15T00:00:00", // No specific time
  //   intervalWeeks: 1,
  //   daysBitmask: 2, // 0b0000010 (Monday)
  //   until: null,
  //   count: null
  // }

  // Update event with recurrence
  eventOperations.update(newEvent.id, { recurrence });
}
```

### Step 4: Store Operations

```typescript
// data.ts - eventOperations.create()
create(event: Omit<Event, "id">): Event {
  const newEvent = {
    ...event,
    id: crypto.randomUUID(), // "550e8400-e29b-41d4-a716-446655440000"
  };

  events.update((currentEvents) => sortEvents([...currentEvents, newEvent]));
  toasts.show("Event created successfully", "success");
  return newEvent;
}

// Final stored event:
const storedEvent = {
  id: "550e8400-e29b-41d4-a716-446655440000",
  title: "Weekly Team Meeting",
  start: new Date("2024-01-15T00:00:00.000Z"), // 00:00 UTC (no specific time)
  end: new Date("2024-01-15T00:00:00.000Z"),   // Same as start = zero duration
  description: "Weekly team sync - time TBD",
  timeLabel: "some-timing",
  importance: "medium",
  tzid: "Asia/Tokyo",
  recurrence: {
    type: "WEEKLY_BITMASK",
    anchorLocalStartISO: "2024-01-15T00:00:00", // No specific time
    intervalWeeks: 1,
    daysBitmask: 2, // Monday
    until: null,
    count: null
  }
};
```

### Step 5: Recurrence Occurrence Generation

When the calendar needs to display events for a date range, the recurrence system generates occurrences:

```typescript
// recurrence.store.ts - loadOccurrences()
export async function loadOccurrences(
  events: Event[],
  windowStart: Date,
  windowEnd: Date,
) {
  const mgr = await getManager();
  const DateTime = (await import("luxon")).DateTime;

  // Filter recurring events
  const recurringEvents = events.filter(
    (event) => event.recurrence && event.recurrence.type !== "NONE",
  );

  // Process the weekly standup event
  for (const event of recurringEvents) {
    const tzid = event.tzid || "Asia/Tokyo";

    // Extract local time components (no specific time for some-timing events)
    const localTime = {
      year: 2024,
      month: 1,
      day: 15,
      hour: 0, // No specific time
      minute: 0,
      second: 0,
    };

    // Create DateTime in the specified timezone
    const startLocalISO = DateTime.fromObject(localTime, { zone: tzid }).toISO({
      suppressMilliseconds: true,
      includeOffset: false,
    }); // "2024-01-15T00:00:00"

    const durationMs = 0; // Zero duration for some-timing events

    // Create event in manager
    const createdEvent = await mgr.createEvent({
      title: "Weekly Team Meeting",
      description: "Weekly team sync - time TBD",
      importance: "medium",
      timeLabel: "some-timing",
      startLocalISO,
      tzid,
      durationMs,
      recurrence: event.recurrence,
    });
  }

  // Generate occurrences for the window (e.g., January 2024)
  const windowStart = new Date("2024-01-01T00:00:00.000Z");
  const windowEnd = new Date("2024-01-31T23:59:59.999Z");
  const rawOccurrences = await mgr.getOccurrencesWindow(windowStart, windowEnd);
}
```

### Step 6: Weekly Bitmask Occurrence Generation

```typescript
// manager.ts - generateWeeklyBitmaskOccurrences()
function generateWeeklyBitmaskOccurrences(
  event,
  rule,
  windowStartUtc,
  windowEndUtc,
) {
  const occurrences = [];
  const anchorDT = DateTime.fromISO("2024-01-15T00:00:00", {
    zone: "Asia/Tokyo",
  }); // No specific time

  const days = getDaysFromBitmask(2); // [1] (Monday = 1)
  const windowStartDT = DateTime.fromJSDate(windowStartUtc, {
    zone: "utc",
  }).setZone("Asia/Tokyo");
  const windowEndDT = DateTime.fromJSDate(windowEndUtc, {
    zone: "utc",
  }).setZone("Asia/Tokyo");

  let currentWeek = anchorDT.startOf("week"); // 2024-01-15 (Monday)
  let count = 0;

  // Generate occurrences week by week
  while (currentWeek <= windowEndDT && count < 1000) {
    const weeksDiff = currentWeek.diff(anchorDT.startOf("week"), "weeks").weeks;
    if (weeksDiff >= 0 && weeksDiff % 1 === 0) {
      // Every week

      // Generate occurrence for Monday (no specific time)
      const occurrenceDT = currentWeek.set({
        weekday: 1, // Monday
        hour: 0, // No specific time
        minute: 0,
        second: 0,
      });

      const occurrenceUtc = occurrenceDT.toUTC().toJSDate();

      if (occurrenceUtc >= windowStartUtc && occurrenceUtc <= windowEndUtc) {
        occurrences.push({
          eventId: event.id,
          startUtc: occurrenceUtc,
          endUtc: new Date(occurrenceUtc.getTime() + 0), // Zero duration
          originalLocalISO: occurrenceDT.toISO({
            suppressMilliseconds: true,
            includeOffset: false,
          }),
        });
        count++;
      }
    }

    currentWeek = currentWeek.plus({ weeks: 1 });
  }

  return occurrences;
}

// Generated occurrences for January 2024:
const generatedOccurrences = [
  {
    eventId: "550e8400-e29b-41d4-a716-446655440000",
    startUtc: new Date("2024-01-15T00:00:00.000Z"), // Mon Jan 15, 00:00 JST (no specific time)
    endUtc: new Date("2024-01-15T00:00:00.000Z"), // Same as start = zero duration
    originalLocalISO: "2024-01-15T00:00:00",
  },
  {
    eventId: "550e8400-e29b-41d4-a716-446655440000",
    startUtc: new Date("2024-01-22T00:00:00.000Z"), // Mon Jan 22, 00:00 JST (no specific time)
    endUtc: new Date("2024-01-22T00:00:00.000Z"), // Same as start = zero duration
    originalLocalISO: "2024-01-22T00:00:00",
  },
  {
    eventId: "550e8400-e29b-41d4-a716-446655440000",
    startUtc: new Date("2024-01-29T00:00:00.000Z"), // Mon Jan 29, 00:00 JST (no specific time)
    endUtc: new Date("2024-01-29T00:00:00.000Z"), // Same as start = zero duration
    originalLocalISO: "2024-01-29T00:00:00",
  },
];
```

### Step 7: Store Update and UI Reactivity

```typescript
// recurrence.store.ts - Update store with generated occurrences
recurrenceStore.update((s) => ({
  ...s,
  occurrences: generatedOccurrences,
  loading: false,
  error: null,
  lastUpdated: new Date(),
}));

// CalendarView.svelte - Reactive display
$effect(() => {
  const $events = get(events);
  const $recurrenceState = get(recurrenceStore);

  // Combine regular events with generated occurrences
  const allDisplayEvents = [
    ...$events,
    ...$recurrenceState.occurrences.map((occ) => ({
      ...occ,
      // Convert occurrence back to Event format for display
      start: occ.startUtc,
      end: occ.endUtc,
    })),
  ];

  // Update display
  displayEvents = allDisplayEvents;
});
```

### Step 8: Display Rendering

```typescript
// CalendarView.svelte - Timeline rendering
function getEventsForTimeline(events: Event[], targetDate: Date): Event[] {
  return getEventsForDate(events, targetDate).filter(event => {
    // Include timed events (positioned by time) and all-day events (full height)
    // Exclude some-timing events (they don't have specific times)
    return event.timeLabel === "timed" || event.timeLabel === "all-day";
  });
}

// For our weekly team meeting, it won't appear in timeline because timeLabel is "some-timing"
// But it will appear in the calendar grid view with "どこかのタイミングで" label
// All-day events will appear in timeline with full height (00:00-23:59)
// Timed events will appear in timeline positioned by their actual times

// Calendar grid display
{#each getEventsForDate(allDisplayEvents, day) as event (event.id)}
  <div class="event-bar">
    <span class="event-label">{event.title}</span>
    {#if event.timeLabel === 'some-timing'}
      <div class="event-time some-timing">どこかのタイミングで</div>
    {/if}
  </div>
{/each}
```

### Step 9: Event Interaction and Editing

When user clicks on a recurring occurrence:

```typescript
// CalendarView.svelte - Event click handler
onclick={() => {
  // Find master event if this is a recurring occurrence
  const masterEvent = $events.find(e => e.id === event.eventId) || event;
  controller.editEvent(masterEvent);
  parseRecurrenceForEdit(masterEvent);
  showEventForm = true;
}}

// AppController.editEvent()
editEvent(event: Event): void {
  // Determine time label based on event duration
  const isAllDay = event.end.getTime() - event.start.getTime() >= 24 * 60 * 60 * 1000 - 1000;
  const timeLabel = event.timeLabel || (isAllDay ? "all-day" : "some-timing");

  this.eventForm.set({
    title: event.title,
    start: utcToLocalDateTimeString(event.start), // "2024-01-15T00:00" (no specific time)
    end: utcToLocalDateTimeString(event.end),     // "2024-01-15T00:00" (same as start)
    description: event.description || "",
    timeLabel: timeLabel,
    isEditing: true,
    editingId: event.id,
  });
}
```

### Complete Data Flow Summary

```
1. User Input (UI)
   ↓
2. Form State Sync (Component ↔ Controller)
   ↓
3. Validation & Processing (Controller)
   ↓
4. UTC Conversion (Date Utils)
   ↓
5. Store Operations (Data Store)
   ↓
6. Recurrence Generation (Recurrence Manager)
   ↓
7. Occurrence Expansion (Weekly Bitmask Algorithm)
   ↓
8. Store Update (Recurrence Store)
   ↓
9. UI Reactivity (Svelte Stores)
   ↓
10. Display Rendering (Calendar Components)
```

### Key Data Transformations

1. **No Time → Zero Duration**: Empty time fields → `00:00 UTC` with zero duration
2. **Recurrence Rules**: `WEEKLY_BITMASK` with `daysBitmask: 2` (Monday)
3. **Occurrence Generation**: Single event → Multiple occurrences across time window (all at 00:00)
4. **Display Filtering**: Timeline excludes `some-timing` events (they don't have specific times)
5. **Visual Truncation**: Multi-day events truncated for day view (not applicable here)

### Timezone Handling Example

```typescript
// For some-timing events, no specific time is set
const localTime = "2024-01-15T00:00:00"; // No specific time, just date

// Convert to UTC for storage
const utcTime = DateTime.fromISO(localTime, { zone: "Asia/Tokyo" })
  .toUTC()
  .toJSDate(); // 2024-01-15T00:00:00.000Z

// Convert back to local for display (shows as date-only)
const displayTime = DateTime.fromJSDate(utcTime, { zone: "utc" })
  .setZone("Asia/Tokyo")
  .toFormat("yyyy-MM-dd"); // "2024-01-15" (no time shown)
```

This example demonstrates the complete journey of a recurring event from user input through storage, recurrence generation, and display, showing how the system maintains data integrity while providing flexible recurrence patterns and timezone support.

## Conclusion

The current calendar system is well-architected with clear separation of concerns, robust timezone handling, and comprehensive recurrence support. The main complexity comes from:

1. **Timezone Management**: Necessary for global applications
2. **Recurrence Processing**: Complex but required for calendar functionality
3. **Display Logic**: Handles edge cases like multi-day events and overlapping

The system already implements many of the simplified rules requested:

- All-day events stored as 00:00-23:59 UTC
- Some-timing events stored as zero-duration
- Visual truncation without data mutation
- Timeline exclusion of date-only events

Future simplifications should focus on reducing the complexity of form state management and consolidating date utilities while preserving the robust timezone and recurrence handling that makes the system reliable and feature-complete
